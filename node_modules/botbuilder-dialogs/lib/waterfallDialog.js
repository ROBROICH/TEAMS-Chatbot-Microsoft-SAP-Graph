"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const dialog_1 = require("./dialog");
const waterfallStepContext_1 = require("./waterfallStepContext");
/**
 * A waterfall is a dialog that's optimized for prompting a user with a series of questions.
 *
 * @remarks
 * Waterfalls accept a stack of functions which will be executed in sequence. Each waterfall step
 * can ask a question of the user and the user's response will be passed to the next step in the
 * waterfall via `step.result`. A special `step.value` object can be used to persist values between
 * steps:
 *
 * ```JavaScript
 * const { ComponentDialog, WaterfallDialog, TextPrompt, NumberPrompt } = require('botbuilder-dialogs);
 *
 * class FillProfileDialog extends ComponentDialog {
 *     constructor(dialogId) {
 *         super(dialogId);
 *
 *         // Add control flow dialogs
 *         this.addDialog(new WaterfallDialog('start', [
 *             async (step) => {
 *                 // Ask user their name
 *                 return await step.prompt('namePrompt', `What's your name?`);
 *             },
 *             async (step) => {
 *                 // Remember the users answer
 *                 step.values['name'] = step.result;
 *
 *                 // Ask user their age.
 *                 return await step.prompt('agePrompt', `Hi ${step.values['name']}. How old are you?`);
 *             },
 *             async (step) => {
 *                 // Remember the users answer
 *                 step.values['age'] = step.result;
 *
 *                 // End the component and return the completed profile.
 *                 return await step.endDialog(step.values);
 *             }
 *         ]));
 *
 *         // Add prompts
 *         this.addDialog(new TextPrompt('namePrompt'));
 *         this.addDialog(new NumberPrompt('agePrompt'))
 *     }
 * }
 * module.exports.FillProfileDialog = FillProfileDialog;
 * ```
 */
class WaterfallDialog extends dialog_1.Dialog {
    /**
     * Creates a new waterfall dialog containing the given array of steps.
     *
     * @remarks
     * See the [addStep()](#addstep) function for details on creating a valid step function.
     * @param dialogId Unique ID of the dialog within the component or set its being added to.
     * @param steps (Optional) array of asynchronous waterfall step functions.
     */
    constructor(dialogId, steps) {
        super(dialogId);
        this.steps = [];
        if (steps) {
            this.steps = steps.slice(0);
        }
    }
    /**
     * Adds a new step to the waterfall.
     *
     * @remarks
     * All step functions should be asynchronous and return a `DialogTurnResult`. The
     * `WaterfallStepContext` passed into your function derives from `DialogContext` and contains
     * numerous stack manipulation methods which return a `DialogTurnResult` so you can typically
     * just return the result from the DialogContext method you call.
     *
     * The step function itself can be either an asynchronous closure:
     *
     * ```JavaScript
     * const helloDialog = new WaterfallDialog('hello');
     *
     * helloDialog.addStep(async (step) => {
     *     await step.context.sendActivity(`Hello World!`);
     *     return await step.endDialog();
     * });
     * ```
     *
     * A named async function:
     *
     * ```JavaScript
     * async function helloWorldStep(step) {
     *     await step.context.sendActivity(`Hello World!`);
     *     return await step.endDialog();
     * }
     *
     * helloDialog.addStep(helloWorldStep);
     * ```
     *
     * Or a class method that's been bound to its `this` pointer:
     *
     * ```JavaScript
     * helloDialog.addStep(this.helloWorldStep.bind(this));
     * ```
     * @param step Asynchronous step function to call.
     */
    addStep(step) {
        this.steps.push(step);
        return this;
    }
    beginDialog(dc, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Initialize waterfall state
            const state = dc.activeDialog.state;
            state.options = options || {};
            state.values = {
                instanceId: generate_guid()
            };
            this.telemetryClient.trackEvent({ name: 'WaterfallStart', properties: {
                    'DialogId': this.id,
                    'InstanceId': state.values['instanceId']
                } });
            // Run the first step
            return yield this.runStep(dc, 0, dialog_1.DialogReason.beginCalled);
        });
    }
    continueDialog(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // Don't do anything for non-message activities
            if (dc.context.activity.type !== botbuilder_core_1.ActivityTypes.Message) {
                return dialog_1.Dialog.EndOfTurn;
            }
            // Run next step with the message text as the result.
            return yield this.resumeDialog(dc, dialog_1.DialogReason.continueCalled, dc.context.activity.text);
        });
    }
    resumeDialog(dc, reason, result) {
        return __awaiter(this, void 0, void 0, function* () {
            // Increment step index and run step
            const state = dc.activeDialog.state;
            return yield this.runStep(dc, state.stepIndex + 1, reason, result);
        });
    }
    /**
     * Called when an individual waterfall step is being executed.
     *
     * @remarks
     * SHOULD be overridden by derived class that want to add custom logging semantics.
     *
     * ```JavaScript
     * class LoggedWaterfallDialog extends WaterfallDialog {
     *     async onStep(step) {
     *          console.log(`Executing step ${step.index} of the "${this.id}" waterfall.`);
     *          return await super.onStep(step);
     *     }
     * }
     * ```
     * @param step Context object for the waterfall step to execute.
     */
    onStep(step) {
        return __awaiter(this, void 0, void 0, function* () {
            // Log Waterfall Step event. 
            var stepName = this.waterfallStepName(step.index);
            const state = step.activeDialog.state;
            var properties = {
                'DialogId': this.id,
                'InstanceId': state.values['instanceId'],
                'StepName': stepName,
            };
            this.telemetryClient.trackEvent({ name: 'WaterfallStep', properties: properties });
            return yield this.steps[step.index](step);
        });
    }
    runStep(dc, index, reason, result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (index < this.steps.length) {
                // Update persisted step index
                const state = dc.activeDialog.state;
                state.stepIndex = index;
                // Create step context
                let nextCalled = false;
                const step = new waterfallStepContext_1.WaterfallStepContext(dc, {
                    index: index,
                    options: state.options,
                    reason: reason,
                    result: result,
                    values: state.values,
                    onNext: (stepResult) => __awaiter(this, void 0, void 0, function* () {
                        if (nextCalled) {
                            throw new Error(`WaterfallStepContext.next(): method already called for dialog and step '${this.id}[${index}]'.`);
                        }
                        nextCalled = true;
                        return yield this.resumeDialog(dc, dialog_1.DialogReason.nextCalled, stepResult);
                    })
                });
                // Execute step
                return yield this.onStep(step);
            }
            else {
                // End of waterfall so just return to parent
                return yield dc.endDialog(result);
            }
        });
    }
    /**
     * Called when the dialog is ending.
     *
     * @param context Context for the current turn of conversation.
     * @param instance The instance of the current dialog.
     * @param reason The reason the dialog is ending.
     */
    endDialog(context, instance, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = instance.state;
            const instanceId = state.values['instanceId'];
            if (reason === dialog_1.DialogReason.endCalled) {
                this.telemetryClient.trackEvent({ name: 'WaterfallComplete', properties: {
                        'DialogId': this.id,
                        'InstanceId': instanceId,
                    } });
            }
            else if (reason === dialog_1.DialogReason.cancelCalled) {
                var index = instance.state[state.stepIndex];
                var stepName = this.waterfallStepName(index);
                this.telemetryClient.trackEvent({ name: 'WaterfallCancel', properties: {
                        'DialogId': this.id,
                        'StepName': stepName,
                        'InstanceId': instanceId,
                    } });
            }
        });
    }
    waterfallStepName(index) {
        // Log Waterfall Step event. Each event has a distinct name to hook up
        // to the Application Insights funnel.
        var stepName = '';
        if (this.steps[index]) {
            try {
                stepName = this.steps[index].name;
            }
            finally {
                if (stepName === undefined || stepName === '') {
                    stepName = 'Step' + (index + 1) + 'of' + (this.steps.length);
                }
            }
        }
        return stepName;
    }
}
exports.WaterfallDialog = WaterfallDialog;
/*
 * This function generates a GUID-like random number that should be sufficient for our purposes of tracking
 * instances of a given waterfall dialog.
 * Source: https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 */
function generate_guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
}
//# sourceMappingURL=waterfallDialog.js.map