"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const configurable_1 = require("./configurable");
/**
 * Codes indicating why a waterfall step is being called.
 */
var DialogReason;
(function (DialogReason) {
    /**
     * A dialog is being started through a call to `DialogContext.beginDialog()`.
     */
    DialogReason["beginCalled"] = "beginCalled";
    /**
     * A dialog is being continued through a call to `DialogContext.continueDialog()`.
     */
    DialogReason["continueCalled"] = "continueCalled";
    /**
     * A dialog ended normally through a call to `DialogContext.endDialog()`.
     */
    DialogReason["endCalled"] = "endCalled";
    /**
     * A dialog is ending because its being replaced through a call to `DialogContext.replaceDialog()`.
     */
    DialogReason["replaceCalled"] = "replaceCalled";
    /**
     * A dialog was cancelled as part of a call to `DialogContext.cancelAllDialogs()`.
     */
    DialogReason["cancelCalled"] = "cancelCalled";
    /**
     * A step was advanced through a call to `WaterfallStepContext.next()`.
     */
    DialogReason["nextCalled"] = "nextCalled";
})(DialogReason = exports.DialogReason || (exports.DialogReason = {}));
/**
 * Codes indicating the state of the dialog stack after a call to `DialogContext.continueDialog()`
 * or `DialogContext.beginDialog()`.
 */
var DialogTurnStatus;
(function (DialogTurnStatus) {
    /**
     * Indicates that there is currently nothing on the dialog stack.
     */
    DialogTurnStatus["empty"] = "empty";
    /**
     * Indicates that the dialog on top is waiting for a response from the user.
     */
    DialogTurnStatus["waiting"] = "waiting";
    /**
     * Indicates that the dialog completed successfully, the result is available, and the stack is
     * empty.
     */
    DialogTurnStatus["complete"] = "complete";
    /**
     * Indicates that the dialog was cancelled and the stack is empty.
     */
    DialogTurnStatus["cancelled"] = "cancelled";
})(DialogTurnStatus = exports.DialogTurnStatus || (exports.DialogTurnStatus = {}));
/**
 * Base class for all dialogs.
 */
class Dialog extends configurable_1.Configurable {
    /**
     * Creates a new Dialog instance.
     * @param dialogId Optional. unique ID of the dialog.
     */
    constructor(dialogId) {
        super();
        /**
         * The telemetry client for logging events.
         * Default this to the NullTelemetryClient, which does nothing.
         */
        this._telemetryClient = new botbuilder_core_1.NullTelemetryClient();
        this.id = dialogId;
    }
    /**
     * Unique ID of the dialog.
     *
     * @remarks
     * This will be automatically generated if not specified.
     */
    get id() {
        if (this._id === undefined) {
            this._id = this.onComputeId();
        }
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Retrieve the telemetry client for this dialog.
     */
    get telemetryClient() {
        return this._telemetryClient;
    }
    /**
     * Set the telemetry client for this dialog.
     */
    set telemetryClient(client) {
        this._telemetryClient = client ? client : new botbuilder_core_1.NullTelemetryClient();
    }
    /**
     * Called when an instance of the dialog is the active dialog and a new activity is received.
     *
     * @remarks
     * SHOULD be overridden by dialogs that support multi-turn conversations. The default
     * implementation calls `DialogContext.endDialog()`.
     * @param dc The dialog context for the current turn of conversation.
     */
    continueDialog(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // By default just end the current dialog.
            return dc.endDialog();
        });
    }
    /**
     * Called when an instance of the dialog is being returned to from another dialog.
     *
     * @remarks
     * SHOULD be overridden by multi-turn dialogs that start other dialogs using
     * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The default implementation calls
     * `DialogContext.endDialog()` with any results returned from the ending dialog.
     * @param dc The dialog context for the current turn of conversation.
     * @param reason The reason the dialog is being resumed. This will typically be a value of `DialogReason.endCalled`.
     * @param result (Optional) value returned from the dialog that was called. The type of the value returned is dependant on the dialog that was called.
     */
    resumeDialog(dc, reason, result) {
        return __awaiter(this, void 0, void 0, function* () {
            // By default just end the current dialog and return result to parent.
            return dc.endDialog(result);
        });
    }
    /**
     * Called when the dialog has been requested to re-prompt the user for input.
     *
     * @remarks
     * SHOULD be overridden by multi-turn dialogs that wish to provide custom re-prompt logic. The
     * default implementation performs no action.
     * @param context Context for the current turn of conversation.
     * @param instance The instance of the current dialog.
     */
    repromptDialog(context, instance) {
        return __awaiter(this, void 0, void 0, function* () {
            // No-op by default
        });
    }
    /**
     * Called when the dialog is ending.
     *
     * @remarks
     * SHOULD be overridden by dialogs that wish to perform some logging or cleanup action anytime
     * the dialog ends.
     * @param context Context for the current turn of conversation.
     * @param instance The instance of the current dialog.
     * @param reason The reason the dialog is ending.
     */
    endDialog(context, instance, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            // No-op by default
        });
    }
    /// <summary>
    /// Called when an event has been raised, using `DialogContext.emitEvent()`, by either the current dialog or a dialog that the current dialog started.
    /// </summary>
    /// <param name="dc">The dialog context for the current turn of conversation.</param>
    /// <param name="e">The event being raised.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>True if the event is handled by the current dialog and bubbling should stop.</returns>
    onDialogEvent(dc, e) {
        return __awaiter(this, void 0, void 0, function* () {
            // Before bubble
            let handled = yield this.onPreBubbleEventAsync(dc, e);
            // Bubble as needed
            if (!handled && e.bubble && dc.parent != undefined) {
                handled = yield dc.parent.emitEvent(e.name, e.value, true, false);
            }
            // Post bubble
            if (!handled) {
                handled = yield this.onPostBubbleEventAsync(dc, e);
            }
            return handled;
        });
    }
    /**
     * Called before an event is bubbled to its parent.
     *
     * @remarks
     * This is a good place to perform interception of an event as returning `true` will prevent
     * any further bubbling of the event to the dialogs parents and will also prevent any child
     * dialogs from performing their default processing.
     * @param dc The dialog context for the current turn of conversation.
     * @param e The event being raised.
     * @returns Whether the event is handled by the current dialog and further processing should stop.
     */
    onPreBubbleEventAsync(dc, e) {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    /**
     * Called after an event was bubbled to all parents and wasn't handled.
     *
     * @remarks
     * This is a good place to perform default processing logic for an event. Returning `true` will
     * prevent any processing of the event by child dialogs.
     * @param dc The dialog context for the current turn of conversation.
     * @param e The event being raised.
     * @returns Whether the event is handled by the current dialog and further processing should stop.
     */
    onPostBubbleEventAsync(dc, e) {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    /**
     * Called when a unique ID needs to be computed for a dialog.
     *
     * @remarks
     * SHOULD be overridden to provide a more contextually relevant ID. The preferred pattern for
     * ID's is `<dialog type>(this.hashedLabel('<dialog args>'))`.
     */
    onComputeId() {
        throw new Error(`Dialog.onComputeId(): not implemented.`);
    }
    /**
     * Aids with computing a unique ID for a dialog by computing a 32 bit hash for a string.
     *
     * @remarks
     * The source for this function was derived from the following article:
     *
     * https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
     *
     * @param label String to generate a hash for.
     * @returns A string that is 15 characters or less in length.
     */
    hashedLabel(label) {
        const l = label.length;
        if (label.length > 15) {
            let hash = 0;
            for (let i = 0; i < l; i++) {
                const chr = label.charCodeAt(i);
                hash = ((hash << 5) - hash) + chr;
                hash |= 0; // Convert to 32 bit integer
            }
            label = `${label.substr(0, 5)}${hash.toString()}`;
        }
        return label;
    }
}
/**
 * Signals the end of a turn by a dialog method or waterfall/sequence step.
 */
Dialog.EndOfTurn = { status: DialogTurnStatus.waiting };
exports.Dialog = Dialog;
//# sourceMappingURL=dialog.js.map