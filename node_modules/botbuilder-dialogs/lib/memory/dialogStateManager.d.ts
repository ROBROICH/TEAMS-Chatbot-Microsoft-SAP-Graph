/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { PathResolver } from './pathResolvers';
import { MemoryScope } from './scopes';
import { DialogContext } from '../dialogContext';
import { ConversationState, UserState } from 'botbuilder-core';
export interface DialogStateManagerConfiguration {
    /**
     * List of path resolvers used to evaluate memory paths.
     */
    readonly pathResolvers: PathResolver[];
    /**
     * List of the supported memory scopes.
     */
    readonly memoryScopes: MemoryScope[];
}
/**
 * The DialogStateManager manages memory scopes and path resolvers.
 *
 * @remarks
 * MemoryScopes are named root level objects, which can exist either in the dialog context or off
 * of turn state. Path resolvers allow for shortcut behavior for mapping things like
 * $foo -> dialog.foo
 */
export declare class DialogStateManager {
    private readonly dialogContext;
    private _config;
    constructor(dc: DialogContext);
    /**
     * Gets or sets the configured path resolvers and memory scopes for the dialog state manager.
     *
     * @remarks
     * There is a single set of configuration information for a given chain of dialog contexts.
     * Assigning a new configuration to any DialogStateManager within the chain will update the
     * configuration for the entire chain.
     */
    configuration: DialogStateManagerConfiguration;
    /**
     * Get the value from memory using path expression.
     *
     * @remarks
     * This always returns a CLONE of the memory, any modifications to the result will not affect memory.
     * @param T The value type to return.
     * @param pathExpression Path expression to use.
     * @param defaultValue (Optional) default value to use if the path isn't found. May be a function that returns the default value to use.
     * @returns The found value or undefined if not found and no `defaultValue` specified.
     */
    getValue<T = any>(pathExpression: string, defaultValue?: T | (() => T)): T;
    /**
     * Set memory to value.
     * @param pathExpression Path to memory.
     * @param value Value to set.
     */
    setValue(pathExpression: string, value: any): void;
    /**
     * Delete property from memory
     * @param path The leaf property to remove.
     */
    deleteValue(pathExpression: string): void;
    /**
     * Ensures that all memory scopes have been loaded for the current turn.
     *
     * @remarks
     * This should be called at the beginning of the turn.
     */
    loadAllScopes(): Promise<void>;
    /**
     * Saves any changes made to memory scopes.
     *
     * @remarks
     * This should be called at the end of the turn.
     */
    saveAllChanges(): Promise<void>;
    /**
     * Deletes all of the backing memory for a given scope.
     */
    deleteScopesMemory(name: string): Promise<void>;
    /**
     * Normalizes the path segments of a passed in path.
     *
     * @remarks
     * A path of `profile.address[0]` will be normalized to `profile.address.0`.
     * @param pathExpression The path to normalize.
     * @returns The normalized path.
     */
    parsePath(pathExpression: string): (string | number)[];
    /**
     * Transform the path using the registered path transformers.
     * @param pathExpression The path to transform.
     * @returns The transformed path.
     */
    transformPath(pathExpression: string): string;
    /**
     * Gets all memory scopes suitable for logging.
     * @returns Object which represents all memory scopes.
     */
    getMemorySnapshot(): object;
    private resolveSegments;
    private findObjectKey;
    private getMemoryScope;
    static createStandardConfiguration(conversationState?: ConversationState, userState?: UserState): DialogStateManagerConfiguration;
}
