"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const payloadAssemblerManager_1 = require("./payloads/payloadAssemblerManager");
const sendOperations_1 = require("./payloads/sendOperations");
const streamManager_1 = require("./payloads/streamManager");
const protocol_base_1 = require("./utilities/protocol-base");
class ProtocolAdapter {
    /// <summary>
    /// Creates a new instance of the protocol adapter class.
    /// </summary>
    /// <param name="requestHandler">The handler that will process incoming requests.</param>
    /// <param name="requestManager">The manager that will process outgoing requests.</param>
    /// <param name="sender">The sender for use with outgoing requests.</param>
    /// <param name="receiver">The receiver for use with incoming requests.</param>
    constructor(requestHandler, requestManager, sender, receiver) {
        this.requestHandler = requestHandler;
        this.requestManager = requestManager;
        this.payloadSender = sender;
        this.payloadReceiver = receiver;
        this.sendOperations = new sendOperations_1.SendOperations(this.payloadSender);
        this.streamManager = new streamManager_1.StreamManager(this.onCancelStream);
        this.assemblerManager = new payloadAssemblerManager_1.PayloadAssemblerManager(this.streamManager, (id, response) => this.onReceiveResponse(id, response), (id, request) => this.onReceiveRequest(id, request));
        this.payloadReceiver.subscribe((header) => this.assemblerManager.getPayloadStream(header), (header, contentStream, contentLength) => this.assemblerManager.onReceive(header, contentStream, contentLength));
    }
    /// <summary>
    /// Sends a request over the attached request manager.
    /// </summary>
    /// <param name="request">The outgoing request to send.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    sendRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestId = protocol_base_1.generateGuid();
            yield this.sendOperations.sendRequest(requestId, request);
            return this.requestManager.getResponse(requestId);
        });
    }
    /// <summary>
    /// Executes the receive pipeline when a request comes in.
    /// </summary>
    /// <param name="id">The id the resources created for the response will be assigned.</param>
    /// <param name="request">The incoming request to process.</param>
    onReceiveRequest(id, request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.requestHandler) {
                let response = yield this.requestHandler.processRequest(request);
                if (response) {
                    yield this.sendOperations.sendResponse(id, response);
                }
            }
        });
    }
    /// <summary>
    /// Executes the receive pipeline when a response comes in.
    /// </summary>
    /// <param name="id">The id the resources created for the response will be assigned.</param>
    /// <param name="response">The incoming response to process.</param>
    onReceiveResponse(id, response) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestManager.signalResponse(id, response);
        });
    }
    /// <summary>
    /// Executes the receive pipeline when a cancellation comes in.
    /// </summary>
    /// <param name="contentStreamAssembler">
    /// The payload assembler processing the incoming data that this
    /// cancellation request targets.
    /// </param>
    onCancelStream(contentStreamAssembler) {
        this.sendOperations.sendCancelStream(contentStreamAssembler.id)
            .catch();
    }
}
exports.ProtocolAdapter = ProtocolAdapter;
//# sourceMappingURL=protocolAdapter.js.map