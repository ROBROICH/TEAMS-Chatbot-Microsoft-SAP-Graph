"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botframework-streaming
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const subscribableStream_1 = require("../subscribableStream");
const payloads_1 = require("../payloads");
const contentStream_1 = require("../contentStream");
/**
 * Assembles payloads for streaming library.
 */
class PayloadAssembler {
    constructor(streamManager, params) {
        this._byteOrderMark = 0xFEFF;
        this._utf = 'utf8';
        if (params.header) {
            this.id = params.header.id;
            this.payloadType = params.header.payloadType;
            this.contentLength = params.header.payloadLength;
            this.end = params.header.end;
        }
        else {
            this.id = params.id;
        }
        if (!this.id) {
            throw Error('An ID must be supplied when creating an assembler.');
        }
        this._streamManager = streamManager;
        this._onCompleted = params.onCompleted;
    }
    getPayloadStream() {
        if (!this.stream) {
            this.stream = this.createPayloadStream();
        }
        return this.stream;
    }
    onReceive(header, stream, contentLength) {
        this.end = header.end;
        if (header.payloadType === payloads_1.PayloadTypes.response || header.payloadType === payloads_1.PayloadTypes.request) {
            this.process(stream)
                .then()
                .catch();
        }
        else if (header.end) {
            stream.end();
        }
    }
    close() {
        this._streamManager.closeStream(this.id);
    }
    createPayloadStream() {
        return new subscribableStream_1.SubscribableStream();
    }
    payloadFromJson(json) {
        return JSON.parse((json.charCodeAt(0) === this._byteOrderMark) ? json.slice(1) : json);
    }
    stripBOM(input) {
        return (input.charCodeAt(0) === this._byteOrderMark) ? input.slice(1) : input;
    }
    process(stream) {
        return __awaiter(this, void 0, void 0, function* () {
            let streamData = stream.read(stream.length);
            if (!streamData) {
                return;
            }
            let streamDataAsString = streamData.toString(this._utf);
            if (this.payloadType === payloads_1.PayloadTypes.request) {
                yield this.processRequest(streamDataAsString);
            }
            else if (this.payloadType === payloads_1.PayloadTypes.response) {
                yield this.processResponse(streamDataAsString);
            }
        });
    }
    processResponse(streamDataAsString) {
        return __awaiter(this, void 0, void 0, function* () {
            let responsePayload = this.payloadFromJson(this.stripBOM(streamDataAsString));
            let receiveResponse = { streams: [], statusCode: responsePayload.statusCode };
            yield this.processStreams(responsePayload, receiveResponse);
        });
    }
    processRequest(streamDataAsString) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestPayload = this.payloadFromJson(streamDataAsString);
            let receiveRequest = { streams: [], path: requestPayload.path, verb: requestPayload.verb };
            yield this.processStreams(requestPayload, receiveRequest);
        });
    }
    processStreams(responsePayload, receiveResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            if (responsePayload.streams) {
                responsePayload.streams.forEach((responseStream) => {
                    let contentAssembler = this._streamManager.getPayloadAssembler(responseStream.id);
                    contentAssembler.payloadType = responseStream.contentType;
                    contentAssembler.contentLength = responseStream.length;
                    receiveResponse.streams.push(new contentStream_1.ContentStream(responseStream.id, contentAssembler));
                });
            }
            yield this._onCompleted(this.id, receiveResponse);
        });
    }
}
exports.PayloadAssembler = PayloadAssembler;
//# sourceMappingURL=payloadAssembler.js.map