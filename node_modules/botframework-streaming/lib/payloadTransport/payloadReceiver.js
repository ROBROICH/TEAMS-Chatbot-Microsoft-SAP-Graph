"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const payloadTypes_1 = require("../payloads/payloadTypes");
const headerSerializer_1 = require("../payloads/headerSerializer");
const payloadConstants_1 = require("../payloads/payloadConstants");
const transportDisconnectedEvent_1 = require("./transportDisconnectedEvent");
/**
 * Payload receiver for straming.
 */
class PayloadReceiver {
    constructor() {
        this.disconnected = function (sender, events) { };
    }
    /**
     * Connects to a transport receiver
     *
     * @param receiver The [ITransportReceiver](xref:botframework-streaming.ITransportReceiver) object to pull incoming data from.
     */
    connect(receiver) {
        if (this.isConnected) {
            throw new Error('Already connected.');
        }
        else {
            this._receiver = receiver;
            this.isConnected = true;
            this.runReceive();
        }
    }
    /**
     * Allows subscribing to this receiver in order to be notified when new data comes in.
     *
     * @param getStream Callback when a new stream has been received.
     * @param receiveAction Callback when a new message has been received.
     */
    subscribe(getStream, receiveAction) {
        this._getStream = getStream;
        this._receiveAction = receiveAction;
    }
    /**
     * Force this receiver to disconnect.
     *
     * @param e Event arguments to include when broadcasting disconnection event.
     */
    disconnect(e) {
        let didDisconnect;
        try {
            if (this.isConnected) {
                this._receiver.close();
                didDisconnect = true;
                this.isConnected = false;
            }
        }
        catch (error) {
            this.isConnected = false;
            this.disconnected(this, new transportDisconnectedEvent_1.TransportDisconnectedEvent(error.message));
        }
        this._receiver = null;
        this.isConnected = false;
        if (didDisconnect) {
            this.disconnected(this, e || transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty);
        }
    }
    runReceive() {
        this.receivePackets()
            .catch();
    }
    receivePackets() {
        return __awaiter(this, void 0, void 0, function* () {
            let isClosed;
            while (this.isConnected && !isClosed) {
                try {
                    let readSoFar = 0;
                    while (readSoFar < payloadConstants_1.PayloadConstants.MaxHeaderLength) {
                        this._receiveHeaderBuffer = yield this._receiver.receive(payloadConstants_1.PayloadConstants.MaxHeaderLength - readSoFar);
                        if (this._receiveHeaderBuffer) {
                            readSoFar += this._receiveHeaderBuffer.length;
                        }
                    }
                    let header = headerSerializer_1.HeaderSerializer.deserialize(this._receiveHeaderBuffer);
                    let isStream = header.payloadType === payloadTypes_1.PayloadTypes.stream;
                    if (header.payloadLength > 0) {
                        let bytesActuallyRead = 0;
                        let contentStream = this._getStream(header);
                        while (bytesActuallyRead < header.payloadLength && bytesActuallyRead < payloadConstants_1.PayloadConstants.MaxPayloadLength) {
                            let count = Math.min(header.payloadLength - bytesActuallyRead, payloadConstants_1.PayloadConstants.MaxPayloadLength);
                            this._receivePayloadBuffer = yield this._receiver.receive(count);
                            bytesActuallyRead += this._receivePayloadBuffer.byteLength;
                            contentStream.write(this._receivePayloadBuffer);
                            // If this is a stream we want to keep handing it up as it comes in
                            if (isStream) {
                                this._receiveAction(header, contentStream, bytesActuallyRead);
                            }
                        }
                        if (!isStream) {
                            this._receiveAction(header, contentStream, bytesActuallyRead);
                        }
                    }
                }
                catch (error) {
                    isClosed = true;
                    this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(error.message));
                }
            }
        });
    }
}
exports.PayloadReceiver = PayloadReceiver;
//# sourceMappingURL=payloadReceiver.js.map