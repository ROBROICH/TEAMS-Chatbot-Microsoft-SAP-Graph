"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_1 = require("../utilities");
const createWebSocket = function (url) {
    if (!url) {
        throw new TypeError('Unable to create WebSocket without url.');
    }
    if (utilities_1.doesGlobalWebSocketExist()) {
        return new Function(`return new WebSocket('${url}');`)();
    }
    throw new ReferenceError('Unable to find global.WebSocket which is required for constructing a BrowserWebSocket.');
};
const createFileReader = function () {
    if (utilities_1.doesGlobalFileReaderExist()) {
        return new Function(`return new FileReader();`)();
    }
    throw new ReferenceError('Unable to find global.FileReader. Unable to create FileReader for BrowserWebSocket.');
};
class BrowserWebSocket {
    /**
     * Creates a new instance of the [BrowserWebSocket](xref:botframework-streaming.BrowserWebSocket) class.
     *
     * @param socket The socket object to build this connection on.
     */
    constructor(socket) {
        if (socket) {
            this.webSocket = socket;
        }
    }
    /**
     * Connects to the supporting socket using WebSocket protocol.
     *
     * @param serverAddress The address the server is listening on.
     */
    connect(serverAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let resolver;
            let rejector;
            if (!this.webSocket) {
                this.webSocket = createWebSocket(serverAddress);
            }
            this.webSocket.onerror = (e) => {
                rejector(e);
            };
            this.webSocket.onopen = (e) => {
                resolver(e);
            };
            return new Promise((resolve, reject) => {
                resolver = resolve;
                rejector = reject;
            });
        });
    }
    /**
     * True if the socket is currently connected.
     */
    get isConnected() {
        return this.webSocket.readyState === 1;
    }
    /**
     * Writes a buffer to the socket and sends it.
     *
     * @param buffer The buffer of data to send across the connection.
     */
    write(buffer) {
        this.webSocket.send(buffer);
    }
    /**
     * Close the socket.
     */
    close() {
        this.webSocket.close();
    }
    /**
     * Set the handler for text and binary messages received on the socket.
     */
    setOnMessageHandler(handler) {
        const bufferKey = 'buffer';
        let packets = [];
        this.webSocket.onmessage = (evt) => {
            let fileReader = createFileReader();
            let queueEntry = { buffer: null };
            packets.push(queueEntry);
            fileReader.onload = (e) => {
                let t = e.target;
                queueEntry[bufferKey] = t.result;
                if (packets[0] === queueEntry) {
                    while (0 < packets.length && packets[0][bufferKey]) {
                        handler(packets[0][bufferKey]);
                        packets.splice(0, 1);
                    }
                }
            };
            fileReader.readAsArrayBuffer(evt.data);
        };
    }
    /**
     * Set the callback to call when encountering errors.
     */
    setOnErrorHandler(handler) {
        this.webSocket.onerror = (error) => { if (error) {
            handler(error);
        } };
    }
    /**
     * Set the callback to call when encountering socket closures.
     */
    setOnCloseHandler(handler) {
        this.webSocket.onclose = handler;
    }
}
exports.BrowserWebSocket = BrowserWebSocket;
//# sourceMappingURL=browserWebSocket.js.map